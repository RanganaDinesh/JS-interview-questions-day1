<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1 style="text-align: center;">Day - 1 interview questions</h1>
    <h2>1. Difference between “ == “ and “ === “ operators.</h2>
    <pre>
        Both are comparison operators and they return boolean values always. The difference between both the
         operators is that “==” is used to compare values whereas “ === “ is used to compare both value and datatype.
        examples for : "  ==  "
         var x="2"; 
         var y=2;
         if(x==y){
            console.log(true)
         }
         else{
            console.log(false)
         }
       //  output: true
       examples for : "  ===  "
       var x="2"; 
         var y=2;
         if(x===y){
            console.log(true)
         }
         else{
            console.log(false)
         }
        //output: false

       
    </pre>
    <h2>2. What is a spread operator?</h2>
    <pre>
        The JavaScript spread operator (...) allows us to destructure the non-primitive data types
         like arrays and objects to access the elements individually.
         example:
                    let obj1=[1,2,3,4,5]
                    let obj2=[6,7,8,9,10]
                    let spread=[...obj1,...obj2]
                    console.log(spread)
                    ;/ output:[1,2,3,4,,5,6,7,8,9,10]
    </pre>
    <h2>3. What are the differences between var, let and const?</h2>
    <pre>
            var is a global scoped means variables created using var keyword will be accessible globally.
            It can be redeclared and reinitialized.
            var a = 10;
            let is a block scoped means variables created using let keyword will be accessible only
            in that specific block where it has been declared. It cannot be redeclared but it can be reinitialized.
            let a = 20; 
            const is also block scoped means variables created using const keyword will be accessible only 
            in that specific block where it has been declared. It cannot be redeclared and cannot be reinitialized.
            const a = 30;
    </pre>
    <h2>4. What is execution context?</h2>
    <pre>
        Each and every browser is having a JavaScript Engine, example Google is having V8 engine, Internet Explorer is having Chakra and Mozilla 
        Firefox is having Spider Monkey. JS engine uses a Call stack and also creates a special environment to handle the execution of the JavaScript code. 
        This environment is known as the Execution Context. The Execution Context contains the code that's currently running, and everything that aids in its
         execution. During the Execution Context run-time, the specific code gets parsed by a parser, the variables and functions are stored in memory, 
         executable byte-code gets generated, and the code gets executed. There are two kinds of Execution Context in JavaScript: Global Execution Context (GEC) 
        Function Execution Context (FEC)
    </pre>
    <h2>5. What is meant by first class functions</h2>
    <pre>
        A programming language is said to have First-class functions when functions in that language are treated like any other variable.
         For example, in such a language, a function can be passed asan argument to other functions, can be returned by another function
          and can be assigned as a value to a variable.
          example:
          function person() {
            console.log("Hi Dinesh how are you")
          }
          function persontInfo(wishes) {
            wishes();
          }
          persontInfo(person) //Hi Dinesh how are you
    </pre>
    <h2>5.What are closures?</h2>
    <pre>
        A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). In other words,
         a closure gives you access to an outer function's scope from an inner function. In JavaScript, closures are created every time a function is created, at function 
         creation time.

         example:
         function otterfunction(){
            var name="Dinesh";
            function innerfunction(){
              console.log(name)
            }
            return innerfunction()
          }
          otterfunction()
          // Dinesh 
    </pre>
    <h2>6.Explain call(), apply() and, bind() methods.</h2>
    <pre>
        These all three methods are used to invoke a function where we are supposed to pass an object as first argument and at the time of definition we don't have mention
         this object as a parameter and we can access the values of object by using this keyword in function definition. 

         call(): The call() method invokes a function in which first argument will be the object and rest of the arguments required by 
         function will be provided as an individual arguments.
         examples:
         var person={
            name:"Dinesh"
            
          }
          var person1={
            name:"Karthik"
            
          }
          function greet(wishes,greetings){
            console.log(wishes+" "+this.name+" "+greetings)
          }
          greet.call(person,"Hi","How are you")
          output : Hi Dinesh How are you
          
          apply(): The apply() method invokes a function in which first argument will be the object and rest of the arguments will be passed as an array of elements.

          var person={
            name:"Dinesh"
            
          }
          var person1={
            name:"Karthik"
            
          }
          function greet(wishes,greetings){
            console.log(wishes+" "+this.name+" "+greetings)
          }
          greet.apply(person,["Hi","How are you"])
          bind: The bind() method returns a new function and this function will be having the reference of the object passed, now whenever you want to use this returned
           function in the code you can use it by passing rest of the arguments.
          var person={
            firstname:"Dinesh",
            lastname:"Karthik",
            fullname:function(){
            console.log("Hi"+" "+this.firstname+" "+this.lastname+" "+"How are you")
          }
            
          }
          var person1={
            firstname:"ganesh",
            lastname:"gane"
          }
          
          let details = person.fullname.bind(person1)
          console.log(details())

          //out put : Hi ganesh gane How are you!

    </pre>

</body>
</html>